<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Python Class - PyO3 user guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="./overview.html">Overview</a></li><li class="affix"><a href="./getting_started.html">Getting Started</a></li><li><a href="./conversions.html"><strong>1.</strong> Type Conversions</a></li><li><a href="./exception.html"><strong>2.</strong> Python Exception</a></li><li><a href="./module.html"><strong>3.</strong> Python Module</a></li><li><a href="./function.html"><strong>4.</strong> Python Function</a></li><li><a href="./class.html" class="active"><strong>5.</strong> Python Class</a></li><li><a href="./parallelism.html"><strong>6.</strong> Parallelism</a></li><li><a href="./distribution.html"><strong>7.</strong> Distribution</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">PyO3 user guide</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./class.html#python-class" id="python-class"><h1>Python Class</h1></a>
<p>Python class generation is powered by unstable <a href="https://doc.rust-lang.org/book/first-edition/procedural-macros.html">Procedural Macros</a> and
<a href="https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md">Specialization</a> and <a href="https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md">Const fn</a>
features, so you need to turn on <code>proc_macro</code> and <code>specialization</code> features:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(proc_macro, specialization, const_fn)]

#fn main() {
extern crate pyo3;
#}</code></pre></pre>
<a class="header" href="./class.html#define-new-class" id="define-new-class"><h2>Define new class</h2></a>
<p>To define python custom class, rust struct needs to be annotated with <code>#[py::class]</code> attribute.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use pyo3::prelude::*;

#[py::class]
struct MyClass {
   num: i32,
   debug: bool,
   token: PyToken,
}
#}</code></pre></pre>
<p>The above example generates the following implementations for <code>MyClass</code> struct</p>
<pre><code class="language-rust ignore">impl PyTypeInfo for MyClass { ... }
impl PyTypeObject for MyClass { ... }
impl PyObjectWithToken for MyClass { ... }
impl ToPyObject for MyClass { ... }
impl IntoPyObject for MyClass { ... }
impl ToPyPointer for MyClass { ... }
</code></pre>
<p>Following implementations <code>PyObjectWithToken</code>, <code>ToPyObject</code>, <code>IntoPyObject</code>, <code>ToPyPointer</code>
are generated only if struct contains <code>PyToken</code> attribute.</p>
<p><code>PyToken</code> instance available only in <code>py.init</code> method.</p>
<p>TODO - continue</p>
<a class="header" href="./class.html#pyclass-macro" id="pyclass-macro"><h2>py::class macro</h2></a>
<p>Python class generation is powered by <a href="https://doc.rust-lang.org/book/first-edition/procedural-macros.html">Procedural Macros</a>.
To define python custom class, rust struct needs to be annotated with <code>#[py::class]</code> attribute.
<code>py::class</code> macro accepts following parameters:</p>
<ul>
<li><code>name=XXX</code> - customize class name visible to python code. By default struct name is used as
a class name.</li>
<li><code>freelist=XXX</code> - <code>freelist</code> parameter add support of free allocation list to custom class.
The performance improvement applies to types that are often created and deleted in a row,
so that they can benefit from a freelist. <code>XXX</code> is a number of items for free list.</li>
<li><code>gc</code> - adds support for python garbage collector. classes that build with <code>gc</code> parameter
participate in python garbage collector. If custom class contains references to other
python object that can be collector <code>PyGCProtocol</code> trait has to be implemented.</li>
<li><code>weakref</code> - adds support for python weak references</li>
<li><code>base=BaseType</code> - use custom base class. BaseType is type which is
implements <code>PyTypeInfo</code> trait.</li>
<li><code>subclass</code> - adds subclass support so that Python classes can inherit from this class</li>
<li><code>dict</code> - adds <code>__dict__</code> support, the instances of this type have a dictionary containing instance variables</li>
</ul>
<a class="header" href="./class.html#constructor" id="constructor"><h2>Constructor</h2></a>
<p>By default it is not possible to create instance of custom class from python code.
To declare constructor, you need to define class method and annotate it with <code>#[new]</code>
attribute. Only python <code>__new__</code> method can be specified, <code>__init__</code> is not available.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[py::method]
impl MyClass {

     #[new]
     fn __new__(obj: &amp;PyRawObject, ...) -&gt; PyResult&lt;()&gt; {
         obj.init(|token| {
             MyClass {
                 num: 10,
                 debug: False,
                 token: token
             }
         })
     }
}
#}</code></pre></pre>
<p>Some rules of <code>new</code> method</p>
<ul>
<li>If no method marked with <code>#[new]</code> is declared, object instances can only be created
from Rust, but not from Python.</li>
<li>The first parameter is the raw object, custom <code>new</code> method must initialize object
with value of struct using <code>init</code> method. Type of the object may be the type object of
a derived class declared in Python.</li>
<li>The first parameter implicitly has type <code>&amp;PyRawObject</code>.</li>
<li>For details on <code>parameter-list</code>, see the documentation of <code>Method arguments</code> section.</li>
<li>The return type must be <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements <code>IntoPyObject</code>.
Usually, <code>T</code> will be <code>MyType</code>.</li>
</ul>
<a class="header" href="./class.html#inheritance" id="inheritance"><h2>Inheritance</h2></a>
<p>By default <code>PyObject</code> is used as default base class. To override default base class
<code>base</code> parameter for <code>py::class</code> needs to be used. Value is full path to base class.
<code>__new__</code> method accepts <code>PyRawObject</code> object. <code>obj</code> instance must be initialized
with value of custom class struct. Subclass must call parent's <code>__new__</code> method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
#[py::class]
struct BaseClass {
   val1: usize
}

#[py::class]
impl BaseClass {
   #[new]
   fn __new__(obj: &amp;PyRawObject) -&gt; PyResult&lt;()&gt; {
       obj.init(|t| BaseClass{val1: 10})
   }
   
   pub fn method(&amp;self) -&gt; PyResult&lt;() {
      Ok(())
   }
}

#[py::class(base=BaseClass)]
struct SubClass {
   val2: usize
}

#[py::class]
impl SubClass {
   #[new]
   fn __new__(obj: &amp;PyRawObject) -&gt; PyResult&lt;()&gt; {
       obj.init(|t| SubClass{val2: 10})
       BaseClass::__new__(obj)
   }
   
   fn method2(&amp;self) -&gt; PyResult&lt;()&gt; {
       self.get_base().method()
   }
}
#}</code></pre></pre>
<p><code>ObjectProtocol</code> trait provides <code>get_base()</code> method. It returns reference to instance of
base class.</p>
<a class="header" href="./class.html#object-properties" id="object-properties"><h2>Object properties</h2></a>
<p>Descriptor methods can be defined in
<code>#[methods]</code> <code>impl</code> block only and has to be annotated with <code>#[getter]</code> or <code>[setter]</code>
attributes. i.e.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[py::methods]
impl MyClass {

     #[getter]
     fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
     }
}
#}</code></pre></pre>
<p>Getter or setter function's name is used as property name by default. There are several
ways how to override name.</p>
<p>If function name starts with <code>get_</code> or <code>set_</code> for getter or setter respectively.
Descriptor name becomes function name with prefix removed. This is useful in case os
rust's special keywords like <code>type</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[py::methods]
impl MyClass {

     #[getter]
     fn get_num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
     }

     #[setter]
     fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value
        Ok(())
     }
}
#}</code></pre></pre>
<p>In this case property <code>num</code> is defined. And it is available from python code as <code>self.num</code>.</p>
<p>Also both <code>#[getter]</code> and <code>#[setter]</code> attributes accepts one parameter.
If parameter is specified, it is used and property name. i.e.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[py::methods]
impl MyClass {

     #[getter(number)]
     fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
     }

     #[setter(number)]
     fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value
        Ok(())
     }
}
#}</code></pre></pre>
<p>In this case property <code>number</code> is defined. And it is available from python code as <code>self.number</code>.</p>
<p>For simple cases you can also define getters and setters in your Rust struct field definition, for example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[py:class]
struct MyClass {
  #[prop(get, set)]
  num: i32
}
#}</code></pre></pre>
<p>Then it is available from Python code as <code>self.num</code>.</p>
<a class="header" href="./class.html#instance-methods" id="instance-methods"><h2>Instance methods</h2></a>
<p>To define python compatible method, <code>impl</code> block for struct has to be annotated
with <code>#[py::methods]</code> attribute. <code>pyo3</code> library generates python compatible
wrappers for all functions in this block with some variations, like descriptors,
class method static methods, etc.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[py::methods]
impl MyClass {

     fn method1(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
     }

     fn set_method(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value
        Ok(())
     }
}
#}</code></pre></pre>
<p>Calls to this methods protected by <code>GIL</code>, <code>&amp;self</code> or <code>&amp;mut self</code> can be used.
The return type must be <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements <code>IntoPyObject</code>.</p>
<p><code>Python</code> parameter can be spefieid as part of method signature, in this case <code>py</code> argument
get injected by method wrapper. i.e</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[py::methods]
impl MyClass {

     fn method2(&amp;self, py: Python) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
     }
}
#}</code></pre></pre>
<p>From python prespective <code>method2</code>, in above example, does not accept any arguments.</p>
<a class="header" href="./class.html#class-methods" id="class-methods"><h2>Class methods</h2></a>
<p>To specify class method for custom class, method needs to be annotated
with<code>#[classmethod]</code> attribute.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[py::methods]
impl MyClass {

     #[classmethod]
     fn cls_method(cls: &amp;PyType) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
     }
}
#}</code></pre></pre>
<p>Declares a class method callable from Python.</p>
<ul>
<li>The first parameter is the type object of the class on which the method is called.
This may be the type object of a derived class.</li>
<li>The first parameter implicitly has type <code>&amp;PyType</code>.</li>
<li>For details on <code>parameter-list</code>, see the documentation of <code>Method arguments</code> section.</li>
<li>The return type must be <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements <code>IntoPyObject</code>.</li>
</ul>
<a class="header" href="./class.html#static-methods" id="static-methods"><h2>Static methods</h2></a>
<p>To specify class method for custom class, method needs to be annotated
with <code>#[staticmethod]</code> attribute. The return type must be <code>PyResult&lt;T&gt;</code>
for some <code>T</code> that implements <code>IntoPyObject</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[py::methods]
impl MyClass {

     #[staticmethod]
     fn static_method(param1: i32, param2: &amp;str) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
     }
}
#}</code></pre></pre>
<a class="header" href="./class.html#callable-object" id="callable-object"><h2>Callable object</h2></a>
<p>To specify custom <code>__call__</code> method for custom class, call method needs to be annotated
with <code>#[call]</code> attribute. Arguments of the method are speficied same as for instance method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[py::methods]
impl MyClass {

     #[call]
     #[args(args=&quot;*&quot;)]
     fn __call__(&amp;self, args: &amp;PyTuple) -&gt; PyResult&lt;i32&gt; {
        println!(&quot;MyCLS has been called&quot;);
        Ok(self.num)
     }
}
#}</code></pre></pre>
<a class="header" href="./class.html#method-arguments" id="method-arguments"><h2>Method arguments</h2></a>
<p>By default pyo3 library uses function signature to determine which arguments are required.
Then it scans incoming <code>args</code> parameter and then incoming <code>kwargs</code> parameter. If it can not
find all required parameters, it raises <code>TypeError</code> exception.
It is possible to override default bahavior with <code>#[args(...)]</code> attribute. <code>args</code> attribute
accept comma separated list of parameters in form <code>attr_name=&quot;default value&quot;</code>. Each parameter
has to match method parameter by name.</p>
<p>Each parameter could one of following type:</p>
<ul>
<li>&quot;*&quot;: var arguments separator, each parameter defined after &quot;*&quot; is keyword only paramters.
coresponds to python's <code>def meth(*, arg1.., arg2=..)</code></li>
<li>args=&quot;*&quot;: &quot;args&quot; is var args, coresponds to python's <code>def meth(*args)</code>. Type of <code>args</code>
parameter has to be <code>&amp;PyTuple</code>.</li>
<li>kwargs=&quot;**&quot;: &quot;kwargs&quot; is kwyword arguments, coresponds to python's <code>def meth(**kwargs)</code>.
Type of <code>kwargs</code> parameter has to be <code>Option&lt;&amp;PyDict&gt;</code>.</li>
<li>arg=&quot;Value&quot;: arguments with default value. coresponds to python's <code>def meth(arg=Value)</code>.
if <code>arg</code> argument is defined after var arguments it is treated as keyword argument.
Note that <code>Value</code> has to be valid rust code, pyo3 just inserts it into generated
code unmodified.</li>
</ul>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[py::methods]
impl MyClass {

     #[args(arg1=true, args=&quot;*&quot;, arg2=10, kwargs=&quot;**&quot;)]
     fn method(&amp;self, arg1: bool, args: &amp;PyTuple, arg2: i32, kwargs: Option&lt;&amp;PyTuple&gt;) -&gt; PyResult&lt;i32&gt; {
        Ok(1)
     }
}
#}</code></pre></pre>
<a class="header" href="./class.html#class-customizations" id="class-customizations"><h2>Class customizations</h2></a>
<p>Python object model defines several protocols for different object behavior,
like sequence, mapping or number protocols. pyo3 library defines separate trait for each
of them. To provide specific python object behavior you need to implement specific trait
for your struct. Important note, each protocol implementation block has to be annotated
with <code>#[py::proto]</code> attribute.</p>
<a class="header" href="./class.html#basic-object-customization" id="basic-object-customization"><h3>Basic object customization</h3></a>
<p><a href="https://pyo3.github.io/pyo3/pyo3/class/basic/trait.PyObjectProtocol.html"><code>PyObjectProtocol</code></a> trait provide several basic customizations.</p>
<a class="header" href="./class.html#attribute-access" id="attribute-access"><h4>Attribute access</h4></a>
<p>To customize object attribute access define following methods:</p>
<ul>
<li><code>fn __getattr__(&amp;self, name: FromPyObject) -&gt; PyResult&lt;impl IntoPyObject&gt;</code></li>
<li><code>fn __setattr__(&amp;mut self, name: FromPyObject, value: FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __delattr__(&amp;mut self, name: FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
</ul>
<p>Each methods coresponds to python's <code>self.attr</code>, <code>self.attr = value</code> and <code>del self.attr</code> code.</p>
<a class="header" href="./class.html#string-conversions" id="string-conversions"><h4>String Conversions</h4></a>
<ul>
<li>
<p><code>fn __repr__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
</li>
<li>
<p><code>fn __str__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
<p>Possible return types for <code>__str__</code> and <code>__repr__</code> are <code>PyResult&lt;String&gt;</code> or <code>PyResult&lt;PyString&gt;</code>.
In Python 2.7, Unicode strings returned by <code>__str__</code> and <code>__repr__</code> will be converted to byte strings
by the Python runtime, which results in an exception if the string contains non-ASCII characters.</p>
</li>
<li>
<p><code>fn __bytes__(&amp;self) -&gt; PyResult&lt;PyBytes&gt;</code></p>
<p>On Python 3.x, provides the conversion to <code>bytes</code>.
On Python 2.7, <code>__bytes__</code> is allowed but has no effect.</p>
</li>
<li>
<p><code>fn __unicode__(&amp;self) -&gt; PyResult&lt;PyUnicode&gt;</code></p>
<p>On Python 2.7, provides the conversion to <code>unicode</code>.
On Python 3.x, <code>__unicode__</code> is allowed but has no effect.</p>
</li>
<li>
<p><code>fn __format__(&amp;self, format_spec: &amp;str) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
<p>Special method that is used by the <code>format()</code> builtin and the <code>str.format()</code> method.
Possible return types are <code>PyResult&lt;String&gt;</code> or <code>PyResult&lt;PyString&gt;</code>.</p>
</li>
</ul>
<a class="header" href="./class.html#comparison-operators" id="comparison-operators"><h4>Comparison operators</h4></a>
<ul>
<li>
<p><code>fn __richcmp__(&amp;self, other: impl FromPyObject, op: CompareOp) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Overloads Python comparison operations (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>).
The <code>op</code> argument indicates the comparison operation being performed.
The return type will normally be <code>PyResult&lt;bool&gt;</code>, but any Python object can be returned.
If <code>other</code> is not of the type specified in the signature, the generated code will
automatically <code>return NotImplemented</code>.</p>
</li>
<li>
<p><code>fn __hash__(&amp;self) -&gt; PyResult&lt;impl PrimInt&gt;</code></p>
<p>Objects that compare equal must have the same hash value.
The return type must be <code>PyResult&lt;T&gt;</code> where <code>T</code> is one of Rust's primitive integer types.</p>
</li>
</ul>
<a class="header" href="./class.html#other-methods" id="other-methods"><h4>Other methods</h4></a>
<ul>
<li>
<p><code>fn __bool__(&amp;self) -&gt; PyResult&lt;bool&gt;</code></p>
<p>Determines the &quot;truthyness&quot; of the object.
This method works for both python 3 and python 2,
even on Python 2.7 where the Python spelling was <code>__nonzero__</code>.</p>
</li>
</ul>
<a class="header" href="./class.html#garbage-collector-integration" id="garbage-collector-integration"><h3>Garbage Collector Integration</h3></a>
<p>If your type owns references to other python objects, you will need to
integrate with Python's garbage collector so that the GC is aware of
those references.
To do this, implement <a href="https://pyo3.github.io/pyo3/pyo3/class/gc/trait.PyGCProtocol.html"><code>PyGCProtocol</code></a> trait for your struct.
It includes two methods <code>__traverse__</code> and <code>__clear__</code>.
These correspond to the slots <code>tp_traverse</code> and <code>tp_clear</code> in the Python C API.
<code>__traverse__</code> must call <code>visit.call()</code> for each reference to another python object.
<code>__clear__</code> must clear out any mutable references to other python objects
(thus breaking reference cycles). Immutable references do not have to be cleared,
as every cycle must contain at least one mutable reference.
Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(proc_macro, specialization)]
#fn main() {
extern crate pyo3;

use pyo3::{py, PyObject, PyGCProtocol, PyVisit, PyTraverseError};

#[py::class]
struct ClassWithGCSupport {
    obj: Option&lt;PyObject&gt;,
}

#[py::proto]
impl PyGCProtocol for ClassWithGCSupport {
    fn __traverse__(&amp;self, visit: PyVisit) -&gt; Result&lt;(), PyTraverseError&gt; {
        if let Some(ref obj) = self.obj {
            visit.call(obj)?
        }
        Ok(())
    }

    fn __clear__(&amp;mut self) {
        if let Some(obj) = self.obj.take() {
          // Release reference, this decrements ref counter.
          self.py().release(obj);
        }
    }
}
#}</code></pre></pre>
<p>Special protocol trait implementation has to be annotated with <code>#[py::proto]</code> attribute.</p>
<p>It is also possible to enable gc for custom class using <code>gc</code> parameter for <code>py::class</code> annotation.
i.e. <code>#[py::class(gc)]</code>. In that case instances of custom class participate in python garbage
collector, and it is possible to track them with <code>gc</code> module methods.</p>
<a class="header" href="./class.html#iterator-types" id="iterator-types"><h3>Iterator Types</h3></a>
<p>Iterators can be defined using the
<a href="https://pyo3.github.io/pyo3/pyo3/class/iter/trait.PyIterProtocol.html"><code>PyIterProtocol</code></a> trait.
It includes two methods <code>__iter__</code> and <code>__next__</code>:</p>
<ul>
<li><code>fn __iter__(&amp;mut self) -&gt; PyResult&lt;impl IntoPyObject&gt;</code></li>
<li><code>fn __next__(&amp;mut self) -&gt; PyResult&lt;Option&lt;impl IntoPyObject&gt;&gt;</code></li>
</ul>
<p>Returning <code>Ok(None)</code> from <code>__next__</code> indicates that that there are no further items.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(proc_macro, specialization)]
extern crate pyo3;

use pyo3::{py, PyObject, PyResult, PyIterProtocol};

#[py::class]
struct MyIterator {
    iter: Box&lt;Iterator&lt;Item=PyObject&gt; + Send&gt;
}

#[py::proto]
impl PyIterProtocol {

    fn __iter__(&amp;mut self) -&gt; PyResult&lt;PyObject&gt; {
        Ok(self.into())
    }
    fn __next__(&amp;mut self) -&gt; PyResult&lt;Option&lt;PyObject&gt;&gt; {
        Ok(self.iter.next())
    }
}
# fn main() {}
</code></pre></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./function.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./parallelism.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./function.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./parallelism.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
